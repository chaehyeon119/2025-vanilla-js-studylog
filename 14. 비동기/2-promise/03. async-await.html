<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 🎯 이 예제의 목적: async/await를 사용한 비동기 작업 처리하기
      // async/await는 Promise 체이닝보다 더 읽기 쉽고 이해하기 쉬운 비동기 처리 방법입니다
      // 실제 웹사이트에서는 복잡한 비동기 작업을 동기 코드처럼 작성할 때 자주 사용됩니다

      // 1. 사용자에게 질문을 하고 답변을 받는 함수
      // 이 함수는 Promise를 반환하여 비동기적으로 작동합니다
      function question() {
        // 2. 새로운 Promise 객체 생성
        // Promise는 "나중에 결과를 줄게"라는 약속입니다
        return new Promise((resolve, reject) => {
          // 3. 1초 후에 실행되는 타이머 설정
          // setTimeout은 "1초 후에 이 코드를 실행해"라는 명령어입니다
          setTimeout(() => {
            // 4. 사용자에게 질문하기
            // prompt는 사용자에게 입력창을 띄우는 도구입니다
            const result = prompt("전주 최고의 맛집은?");

            // 5. 사용자 답변 확인하기
            if (result === "허가낸닭발") {
              // 6. 정답인 경우 성공 처리
              // resolve는 "성공했어!"라고 알려주는 함수입니다
              resolve("맞았어요!");
            } else {
              // 7. 틀린 경우 실패 처리
              // reject는 "실패했어!"라고 알려주는 함수입니다
              reject("땡!!!");
            }
          }, 1000); // 1000ms = 1초
        });
      }

      // 8. 첫 번째 단계 작업을 수행하는 함수
      // 이 함수도 Promise를 반환하여 비동기적으로 작동합니다
      function step1(value) {
        // 9. 새로운 Promise 객체 생성
        return new Promise((resolve) => {
          // 10. 1초 후에 실행되는 타이머 설정
          setTimeout(() => {
            // 11. 전달받은 값을 콘솔에 출력하기
            console.log("step1 입력값: ", value);
            // 12. 작업 완료 후 결과 반환
            // resolve는 Promise를 성공으로 완료시키는 함수입니다
            resolve("step1의 resolve에 넣은 값");
          }, 1000); // 1초 대기
        });
      }

      // 13. 두 번째 단계 작업을 수행하는 함수
      function step2(value) {
        // 14. 새로운 Promise 객체 생성
        return new Promise((resolve) => {
          // 15. 1초 후에 실행되는 타이머 설정
          setTimeout(() => {
            // 16. 전달받은 값을 콘솔에 출력하기
            console.log("step2 입력값: ", value);
            // 17. 작업 완료 후 결과 반환
            resolve("step2의 resolve에 넣은 값");
          }, 1000); // 1초 대기
        });
      }

      // 18. 즉시 실행 함수 (IIFE) - async/await 사용
      // async는 "이 함수는 비동기 작업을 할 거야"라고 알려주는 키워드입니다
      (async function () {
        // 19. try-catch로 에러를 안전하게 처리하기
        try {
          // 20. question 함수 실행하고 결과 대기하기
          // await는 "이것이 완료될 때까지 기다려"라는 키워드입니다
          // await는 async 함수 안에서만 사용할 수 있습니다
          const result0 = await question();
          // 21. question 함수의 결과 출력하기
          console.log("question 성공, 정답 맞춤!", result0);

          // 22. step1 함수 실행하고 결과 대기하기
          // result0를 step1 함수에 전달합니다
          const result1 = await step1(result0);
          // 23. step1 함수의 결과 출력하기
          console.log("step1 성공", result1);

          // 24. step2 함수 실행하고 결과 대기하기
          // result1을 step2 함수에 전달합니다
          const result2 = await step2(result1);
          // 25. step2 함수의 결과 출력하기
          console.log("step2 성공", result2);
        } catch (err) {
          // 26. 에러가 발생했을 때 실행되는 코드
          // 어느 단계에서든 에러가 발생하면 이 부분이 실행됩니다
          console.error(err);
        } finally {
          // 27. 성공하든 실패하든 마지막에 항상 실행되는 코드
          // 1초 후에 "FINALLYYYYYY"를 출력합니다
          setTimeout(() => {
            console.log("FINALLYYYYYY");
          }, 1000);
        }
      })(); // ← 여기서 함수를 즉시 실행!

      // 📚 async/await vs Promise 체이닝 비교:
      //
      // Promise 체이닝 방식:
      // question()
      //   .then(result => step1(result))
      //   .then(result => step2(result))
      //   .then(result => console.log(result))
      //   .catch(err => console.error(err));
      //
      // async/await 방식 (현재 코드):
      // const result0 = await question();
      // const result1 = await step1(result0);
      // const result2 = await step2(result1);
      // console.log(result2);

      // 🔍 async/await의 장점:
      // 1. 읽기 쉬움: 동기 코드처럼 보입니다
      // 2. 에러 처리: try-catch로 간단하게 처리
      // 3. 변수 할당: 각 단계의 결과를 변수에 저장 가능
      // 4. 디버깅: 중간에 breakpoint를 쉽게 설정 가능

      // 💡 Promise의 상태:
      // 성공: fulfilled (완료됨)
      // 실패: rejected (거부됨)
      // 처리중: pending (대기중)
    </script>
  </body>
</html>
