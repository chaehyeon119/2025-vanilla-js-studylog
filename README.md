# 2025 Vanilla JavaScript Study Log

## 📚 프로젝트 소개

Vanilla JavaScript 학습 과정을 기록하고 실습하는 저장소입니다.

## 🎯 학습 목표

- JavaScript 기본 문법 마스터
- DOM 조작 및 이벤트 처리
- 비동기 프로그래밍 (Promise, async/await)
- ES6+ 문법 활용
- 실전 프로젝트 구현

## 📊 학습 진행사항

### 섹션 1: JavaScript 기초

- [x] 자바스크립트의 실행 환경 (2025-08-17)
- [x] 변수와 상수 (2025-08-17)
- [x] 자료형과 형 변환 (2025-08-17)
- [x] 연산자 (2025-08-17)
- [x] 조건문 (2025-08-17)
- [x] 함수 (2025-08-17)
- [x] 스코프 (2025-08-18)
- [x] 호이스팅 (2025-08-18)
- [x] 함수 표현식과 화살표 함수 (2025-08-18)
- [x] 객체 (2025-08-18)
- [x] 배열 (2025-08-18)
- [x] 생성자 함수 (2025-08-18)
- [x] 반복문 (2025-08-18)
- [x] 배열 메서드-1 (2025-08-18)
- [x] 배열 메서드-2 (2025-08-18)
- [x] 배열과 객체 구조 분해 할당 (2025-08-18)
- [x] spread와 rest (2025-08-18)

### 섹션 2: 비동기와 API

- [x] 비동기 처리 (2025-08-24)
- [x] 프로미스 객체 (2025-08-24)
- [x] async와 await (2025-08-24)
- [x] API 호출 (2025-08-24)

### 섹션 3: DOM과 DOM API

- [x] 웹과 DOM (2025-08-18)
- [x] DOM API-1 (2025-08-18)
- [x] DOM API-2 (2025-08-19)
- [x] 여러가지 폼 조작 (2025-08-19)

### 섹션 4: this와 화살표 함수

- [x] 자바스크립트의 this-1 (2025-08-18)
- [x] 자바스크립트의 this-2 (2025-08-18)
- [x] this와 화살표 함수 (2025-08-18)

### 섹션 5: 중간 프로젝트

- [x] 1만 시간의 법칙 계산기 (2025-08-25)
- [x] 동물 앨범 만들기 코드 (2025-08-25)
- [x] 동물 앨범 만들기-1-1 (2025-08-25)
- [x] 동물 앨범 만들기-1-2 (2025-08-25)

### 섹션 6: 컴포넌트와 모듈 시스템

- [x] 컴포넌트란 (2025-08-25)
- [x] 모듈 시스템이란 (2025-08-25)
- [ ] 동물 앨범 만들기-2-1 (완료일: )

### 섹션 7: 상태 관리와 SPA

- [ ] 상태 관리란 (완료일: )
- [ ] 동물 앨범 만들기-2-2 (완료일: )
- [ ] 동물 앨범 만들기-2-3 (완료일: )
- [ ] MPA와 SPA (완료일: )
- [ ] SPA와 라우팅 (완료일: )
- [ ] 동물 앨범 만들기-3 (완료일: )
- [ ] express 버전 안내 (완료일: )
- [ ] node.js와 express.js (완료일: )

### 섹션 8: 최종 프로젝트

- [ ] 최종 프로젝트 안내 (완료일: )
- [ ] Trip Wiki 코드 (완료일: )
- [ ] 여행지 정보 웹 사이트(Trip Wiki) (완료일: )
- [ ] 컴포넌트화 작업 (완료일: )
- [ ] CityList 개발 (완료일: )
- [ ] Header 개발 (완료일: )
- [ ] RegionList 개발 (완료일: )
- [ ] CityDetail 개발-1 (완료일: )
- [ ] CityDetail 개발-2 (완료일: )
- [ ] 강의를 마치면서 (완료일: )

---

## 📝 학습 내용 정리

### 📋 목차

1. [🔧 기본 문법](#-기본-문법)

   - [변수와 상수](#변수와-상수)
   - [자료형과 형 변환](#자료형과-형-변환)
   - [연산자](#연산자)
   - [조건문](#조건문)
   - [함수](#함수)

2. [🚀 고급 개념](#-고급-개념)

   - [호이스팅](#호이스팅)
   - [스코프](#스코프)
   - [함수 표현식과 화살표 함수](#함수-표현식과-화살표-함수)
   - [콜백 함수](#콜백-함수)

3. [📦 객체와 배열](#-객체와-배열)

   - [객체 다루기](#객체-다루기)
   - [배열 메서드](#배열-메서드)
   - [생성자 함수](#생성자-함수)

4. [🔄 반복문과 배열 고급 메서드](#-반복문과-배열-고급-메서드)

   - [반복문](#반복문)
   - [forEach 메서드](#foreach-메서드)
   - [map 메서드](#map-메서드)
   - [기타 배열 메서드](#기타-배열-메서드)

5. [🌐 DOM과 웹](#-dom과-웹)

   - [DOM이란](#dom이란)
   - [DOM API](#dom-api)
   - [요소 생성과 추가](#요소-생성과-추가)
   - [innerHTML vs appendChild](#innerhtml-vs-appendchild)
   - [폼 요소 조작](#폼-요소-조작)

6. [🎯 구조 분해 할당](#-구조-분해-할당)

   - [배열 구조 분해 할당](#배열-구조-분해-할당)
   - [객체 구조 분해 할당](#객체-구조-분해-할당)

7. [📤 Spread와 Rest](#-spread와-rest)

   - [Spread 문법](#spread-문법)
   - [Rest 문법](#rest-문법)
   - [Spread와 Rest 함께 사용](#spread와-rest-함께-사용)

8. [🎯 this와 화살표 함수](#-this와-화살표-함수)

   - [JavaScript의 this](#javascript의-this)
   - [일반 함수 vs 화살표 함수의 this](#일반-함수-vs-화살표-함수의-this)
   - [setTimeout에서의 this](#settimeout에서의-this)

9. [💡 핵심 개념 정리](#-핵심-개념-정리)
   - [바닐라 JS의 의미](#바닐라-js의-의미)
   - [비교 연산 주의사항](#비교-연산-주의사항)
   - [변수 초기화](#변수-초기화)
   - [return vs console.log](#return-vs-consolelog)
   - [이벤트 핸들러 주의사항](#이벤트-핸들러-주의사항)
   - [data-\* 속성](#data--속성)

---

### 🔧 기본 문법

#### 변수와 상수

```javascript
let num = 10; // 변수 (재할당 가능)
const PI = 3.14; // 상수 (재할당 불가)
var oldWay = "구식"; // var (사용 권장하지 않음)
```

#### 자료형과 형 변환

```javascript
// 기본 자료형
let string = "문자열";
let number = 42;
let boolean = true;
let nullValue = null;
let undefinedValue = undefined;

// 형 변환
let strToNum = parseInt("123"); // 문자열 → 숫자
let numToStr = String(123); // 숫자 → 문자열
```

#### 연산자

```javascript
// 증감 연산자
let num = 10;
console.log(num++); // 10 (후위 연산)
console.log(num); // 11
console.log(++num); // 12 (전위 연산)

// 비교 연산자
console.log(10 === "10"); // false (엄격한 비교)
console.log(10 == "10"); // true (느슨한 비교)

// 논리 연산자
console.log(true && false); // false (AND)
console.log(true || false); // true (OR)
console.log(!true); // false (NOT)

// null 병합 연산자
let value = undefined ?? "기본값"; // "기본값"

// 삼항 연산자
let result = 10 > 5 ? "크다" : "작다"; // "크다"
```

#### 조건문

```javascript
// if-else
if (num > 10) {
  console.log("10보다 크다");
} else if (num === 10) {
  console.log("10이다");
} else {
  console.log("10보다 작다");
}

// switch-case
switch (fruit) {
  case "apple":
    console.log("사과");
    break;
  case "banana":
    console.log("바나나");
    break;
  default:
    console.log("다른 과일");
}
```

#### 함수

```javascript
// 함수 선언식
function add(num1, num2) {
  return num1 + num2;
}

// 함수 표현식
const multiply = function (num1, num2) {
  return num1 * num2;
};

// 화살표 함수
const divide = (num1, num2) => num1 / num2;

// Early Return Pattern (가독성 좋은 코드)
function compare(num) {
  if (num === 0) return "0이다";
  if (num < 0) return "음수이다";
  if (num >= 10) return "10 이상이다";
  return "0보다 크고 10보다 작다";
}
```

---

### 🚀 고급 개념

#### 호이스팅

**함수 호이스팅**

```javascript
sayHi(); // ✅ 가능

function sayHi() {
  console.log("안녕");
}
```

**변수 호이스팅**

```javascript
console.log(num2); // ❌ 에러 발생
let num2 = 123;

// 자바스크립트 엔진이 해석하는 순서:
// let, const는 Temporal Dead Zone(TDZ)에 위치
// 변수가 초기화가 진행될 때까지 TDZ에 위치
```

**var vs let/const 호이스팅 차이**

```javascript
console.log(num2); // undefined
var num2 = 123;

// 자바스크립트 엔진이 해석하는 순서:
// var num;
// console.log(num);
// num = 123;

// var 키워드는 변수를 생성한 다음 바로 메모리에 변수 num 공간을 할당
// let, const는 변수가 초기화될 때까지 메모리 공간이 확보되지 않아서 TDZ에 위치
```

> ⚠️ **중요**: 호이스팅은 자바스크립트의 기본 성질이지만, 호이스팅이 많이 발생하게 작성된 코드는 가독성이 좋지 않습니다. 되도록 var보다는 let이나 const를 사용하고, 변수와 함수의 선언문 이후에 변수와 함수에 접근하는 코드를 작성하는 것이 좋습니다.

#### 스코프

**전역 스코프와 지역 스코프**

```javascript
let global = "나는 전역 변수입니다.";

function outerFunction() {
  let outer = "나는 외부 함수의 변수입니다.";

  function innerFunction() {
    let inner = "나는 내부 함수의 변수입니다.";

    console.log(global); // ✅ 전역 변수 접근 가능
    console.log(outer); // ✅ 외부 함수 변수 접근 가능
    console.log(inner); // ✅ 내부 함수 변수 접근 가능
  }

  innerFunction();
  console.log(global); // ✅ 전역 변수 접근 가능
  console.log(outer); // ✅ 외부 함수 변수 접근 가능
  // console.log(inner); // ❌ 지역 스코프에 접근할 수 없음
}

outerFunction();
```

#### 함수 표현식과 화살표 함수

**함수 선언식 vs 함수 표현식**

```javascript
// 함수 선언식
hoisted(); // ✅ 가능

function hoisted() {
  console.log("hosting");
}

// 함수 표현식
hoisted(); // ❌ 에러 발생

const hoisted = function () {
  console.log("hoisting");
};

// 화살표 함수
const hoisted = () => {
  console.log("hoisting");
};
```

> 📌 **함수 선언식**은 호이스팅되어 어디서든 호출 가능
> 📌 **함수 표현식**은 변수만 호이스팅되고 값은 나중에 할당 → 미리 호출 불가

#### 콜백 함수

**콜백 함수 기본 개념**

```javascript
// 콜백함수 변경 전
const printResult1 = (a, b) => {
  let result = a + b;
  console.log("결과: " + result);
};

const doubleResult1 = (a, b) => {
  let result = a + b;
  console.log("결과에 2를 곱한 값: " + result * 2);
};

printResult1(5, 3);
doubleResult1(5, 3);

// 콜백함수 변경 후
const calculate = (a, b, callback) => {
  let result = a + b;
  callback(result);
};

const printResult = (result) => {
  console.log("결과: " + result);
};

const doubleResult = (result) => {
  console.log("결과에 2를 곱한 값: " + result * 2);
};

calculate(5, 3, printResult);
calculate(5, 3, doubleResult);

// 콜백 함수 다른 예시
const testFunc = (callback) => {
  callback();
};

testFunc(() => {
  console.log("콜백 함수 테스트");
});
```

---

### 📦 객체와 배열

#### 객체 다루기

**객체 프로퍼티 접근**

```javascript
let car = {
  name: "붕붕",
  model: "morning",
  color: "black",
};

// 점 표기법 (일반적인 경우)
console.log(car.name); // '붕붕'

// 괄호 표기법 (동적 키 접근)
const getValue = (key) => {
  console.log(car[key]); // 'black'
};

getValue("color");
```

**프로퍼티 값 변경**

```javascript
const cat = {
  age: 2,
  name: "야옹이",
  color: "yellow",
};

cat.name = "옹이";
cat["color"] = "black";

console.log(cat); // const여도 오류 없이 실행됨

// const로 객체를 선언하더라도 프로퍼티 값을 변경할 수 있음
// (단, 아래 코드는 오류 남 => 객체의 고유한 아이디를 변경하는 것이므로)

// cat = {
//   age: 3,
// }; // TypeError 발생
```

#### 배열 메서드

**배열 앞쪽 조작**

```javascript
// unshift: 배열 맨 앞에 값 추가
let fruits = ["apple", "banana"];
fruits.unshift("grape");
console.log(fruits); // ['grape', 'apple', 'banana']

// shift: 배열 맨 앞의 값 삭제
const colors = ["purple", "skyblue", "green"];
colors.shift();
console.log(colors); // ['skyblue', 'green']
```

**splice 메서드**

```javascript
const colors = ["purple", "skyblue", "green", "yellow", "orange"];
// colors.splice(start, deleteCount);
colors.splice(1, 3);
console.log(colors); // ['purple', 'orange']
console.log(colors.length); // 2
```

#### 생성자 함수

**생성자 함수의 장점**

1. 동일한 구조의 객체 쉽게 생성
2. 코드의 재사용성 높아짐
3. 반복되는 코드 작성 감소

```javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayHi = function () {
    console.log("안녕하세요!" + this.name + "입니다");
  };
}

const person1 = new Person("홍길동", 30, "Manager");
const person2 = new Person("김철수", 25, "Designer");

console.log(person1.name); // '홍길동'
console.log(person1.age); // 30
person1.sayHi(); // '안녕하세요!홍길동입니다'
person2.sayHi(); // '안녕하세요!김철수입니다'
```

---

### 🔄 반복문과 배열 고급 메서드

#### 반복문

```javascript
// 기본 for문
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// for...of (배열 요소에 직접 접근)
for (let element of arr) {
  console.log(element);
}
```

#### forEach 메서드

배열에서 `for` 대신으로 많이 사용하는 메서드입니다.

```javascript
let arr = [1, 2, 3, 4, 5];

// 기본 사용법
arr.forEach((elm) => {
  console.log(elm);
});
// 1
// 2
// 3
// 4
// 5

// 인덱스와 함께 사용
arr.forEach((elm, idx) => {
  console.log(`${idx}번째 요소는 ${elm}입니다.`);
});
// 0번째 요소는 1입니다.
// 1번째 요소는 2입니다.
// ...
// 4번째 요소는 5입니다.
```

#### map 메서드

배열의 각 요소를 변환하여 새로운 배열을 생성합니다.

```javascript
let arr = [1, 2, 3, 4, 5];

// for문으로 구현
let newArray = [];
for (let i = 0; i < arr.length; i++) {
  newArray.push(arr[i] * 10);
}
console.log(newArray); // [10, 20, 30, 40, 50]

// map으로 구현
let newArray = arr.map((elm) => {
  return elm * 10;
});
console.log(newArray); // [10, 20, 30, 40, 50]
```

#### 기타 배열 메서드

**at()과 includes() 메서드**

```javascript
let colors = ["green", "blue", "purple"];

// at(): 음수 인덱스로 뒤에서부터 접근 가능
console.log(colors.at(-1)); // purple
console.log(colors.at(1)); // blue

// includes(): 요소 포함 여부 확인
console.log(colors.includes("blue")); // true
console.log(colors.includes("yellow")); // false

// 두 번째 인자: 시작 인덱스
console.log(colors.includes("blue", 2)); // false (2번째 인덱스부터 blue가 있는지 찾기)
console.log(colors.includes("blue", 1)); // true (1번째 인덱스부터 blue가 있는지 찾기)
```

**indexOf() 메서드**

```javascript
let colors = ["green", "blue", "purple"];

console.log(colors.indexOf("purple")); // 2
console.log(colors.indexOf("yellow")); // -1 (배열에 존재하지 않는 값)
console.log(colors.indexOf("blue", 1)); // 1
```

**findIndex() 메서드**

```javascript
let colors = [
  { id: 1, color: "green" },
  { id: 2, color: "blue" },
  { id: 3, color: "purple" },
];

let idx = colors.findIndex((elm) => elm.color === "purple");
console.log(idx); // 2
```

**filter() 메서드**

```javascript
let colors = [
  { id: 1, color: "green" },
  { id: 2, color: "blue" },
  { id: 3, color: "purple" },
];

let filterArray = colors.filter((elm, idx, array) => elm.id > 1);
console.log(filterArray);
```

**slice() 메서드**

```javascript
let colors = [
  { id: 1, color: "green" },
  { id: 2, color: "blue" },
  { id: 3, color: "purple" },
  { id: 4, color: "yellow" },
];

let sliceArray = colors.slice(1, 3);
console.log(sliceArray);
```

**join() 메서드**

```javascript
let array = ["green", "blue", "yellow", "red"];

console.log(array.join()); // green,blue,yellow,red
console.log(array.join(" ")); // green blue yellow red
```

**sort() 메서드**

```javascript
let colors = ["green", "blue", "purple"];
colors.sort();
console.log(colors); // ["blue", "green", "purple"] (오름차순으로 정렬)

// 내림차순 정렬
const compare = (a, b) => {
  if (a > b) return -1;
  else if (a < b) return 1;
  else return 0;
};

let colors = ["green", "blue", "purple"];
colors.sort(compare);
console.log(colors); // ["purple", "green", "blue"]

// 숫자 오름차순 정렬
const compare = (a, b) => {
  return a - b;
};

let numbers = [1, 100, 25, 50, 120, 3];
numbers.sort(compare);
console.log(numbers); // [1, 3, 25, 50, 100, 120]

// 숫자 내림차순 정렬
const compare = (a, b) => {
  return b - a;
};

let numbers = [1, 100, 25, 50, 120, 3];
numbers.sort(compare);
console.log(numbers); // [120, 100, 50, 25, 3, 1]
```

**reduce() 메서드**

```javascript
let numbers = [1, 100, 25, 50, 120, 3];

// 기본 사용법
let sum = numbers.reduce((acc, cur, idx) => {
  console.log(acc, cur, idx);
  return acc + cur;
});
console.log(sum);

// 초기값 설정
let sum = numbers.reduce((acc, cur, idx) => {
  console.log(acc, cur, idx);
  return acc + cur;
}, 10);
console.log(sum);
```

**Array.isArray() 메서드**

```javascript
let a = Array.isArray([1, 100, 50]);
let b = Array.isArray({ id: 1, color: "green" });
let c = Array.isArray("string");
let d = Array.isArray(undefined);

console.log(a, b, c, d); // true false false false
```

---

### 🌐 DOM과 웹

#### DOM이란?

**Document Object Model(문서 객체 모델)**
HTML로 작성된 요소들을 JavaScript가 이해할 수 있도록 객체로 변환한 것입니다.

**class vs id 사용법**

```html
<!DOCTYPE html>
<html>
  <head>
    <title>DOM Tree</title>
    <meta charset="UTF-8" />
  </head>
  <body>
    <div class="animal-info">
      <div id="name">강아지</div>
      <div id="color">갈색</div>
      <div id="age">2살</div>
    </div>
    <script src="src/index.js"></script>
  </body>
</html>
```

> 📌 **class**는 동일한 값을 여러 요소에 적용할 수 있지만, **id** 값은 고유한 값으로 같은 값을 여러 요소에 지정할 수 없습니다.
>
> - **class**: 반복적으로 사용되는 스타일을 적용할 때 사용
> - **id**: header와 footer 같은 요소나 내부에 있는 세부적인 스타일을 적용할 때 사용

#### DOM API

**getElementById()**

```javascript
// DOM API를 사용해 특정 요소를 변수에 할당할 때에는 일반적으로
// 요소를 할당할 변수의 이름 앞에 '$' 기호를 붙여 작성하거나,
// 변수명의 뒤에 Element를 작성합니다.

let $color = document.getElementById("color");
console.log($color);

// 또는
let colorElement = document.getElementById("color");
console.log(colorElement);
```

**querySelector()**

CSS 선택자로 요소 노드를 반환하는 API입니다.

```javascript
let $animalInfo = document.querySelector("div.animal-info");
let ageElement = document.querySelector("div#age");

console.log($animalInfo);
console.log(ageElement);
```

#### 요소 생성과 추가

**createElement()와 appendChild()**

```javascript
// 새로운 요소 생성
let $type = document.createElement("div");
$type.className = "info-item";
$type.id = "type";

// 텍스트 노드 생성
let $typeText = document.createTextNode("말티즈");

// 요소에 텍스트 추가
$type.appendChild($typeText);

// DOM에 요소 추가
let $animalInfo = document.querySelector("div.animal-info");
$animalInfo.appendChild($type);

console.log($type); // <div class="info-item" id="type">말티즈</div>
```

**요소 생성 과정**

1. `createElement()`: HTML 요소 생성
2. 속성 설정 (`className`, `id` 등)
3. `createTextNode()`: 텍스트 노드 생성 (선택사항)
4. `appendChild()`: 요소를 DOM에 추가

#### innerHTML vs appendChild

**innerHTML 사용법**

```javascript
let $animalInfo = document.querySelector("div.animal-info");
$animalInfo.innerHTML = '<div id="name">고양이</div>';

console.log($animalInfo.innerHTML); // '<div id="name">고양이</div>'
```

**차이점과 주의사항**

| 구분          | innerHTML                   | appendChild             |
| ------------- | --------------------------- | ----------------------- |
| **사용법**    | HTML 문자열로 설정          | 요소 객체로 추가        |
| **기존 요소** | 모든 자식 요소 제거 후 대체 | 기존 요소 유지하며 추가 |
| **성능**      | 상대적으로 느림             | 빠름                    |
| **보안**      | XSS 공격 위험               | 안전                    |
| **권장도**    | 주의해서 사용               | 권장                    |

> ⚠️ **중요**: `innerHTML`을 사용하면 기존의 모든 자식 요소들이 제거되고 새로운 요소로 대체됩니다. 성능이나 보안에 문제가 있기 때문에 가능하다면 `createElement`나 `textContent`와 같은 DOM API를 사용하는 것이 좋습니다.

#### 폼 요소 조작

**input 요소 다루기**

```javascript
// HTML
// <input type="text" id="userName" placeholder="이름을 입력하세요" />
// <input type="password" id="password" placeholder="비밀번호를 입력하세요" />

const $userName = document.getElementById("userName");
const $password = document.getElementById("password");

// 값 설정
$userName.value = "홍길동";

// 입력 이벤트 감지
$password.addEventListener("input", (event) => {
  console.log(event.target.value); // 입력된 값 실시간 출력
});
```

**select 요소 다루기**

```javascript
// HTML
// <select id="fruitSelect">
//   <option value="apple">사과</option>
//   <option value="banana">바나나</option>
//   <option value="cherry">체리</option>
// </select>

const $fruitSelect = document.getElementById("fruitSelect");

// 선택 변경 이벤트 감지
$fruitSelect.addEventListener("change", (event) => {
  console.log(event.target.value); // 선택된 option의 value 출력
});
```

**폼 요소 이벤트 타입**

- `input`: 실시간으로 값이 변경될 때마다 발생
- `change`: 요소의 값이 변경되고 포커스를 잃을 때 발생
- `focus`: 요소에 포커스가 갈 때 발생
- `blur`: 요소에서 포커스가 벗어날 때 발생

```javascript
const $input = document.getElementById("userName");

$input.addEventListener("focus", () => {
  console.log("입력 필드에 포커스됨");
});

$input.addEventListener("blur", () => {
  console.log("입력 필드에서 포커스 벗어남");
});
```

---

### 🎯 구조 분해 할당

#### 배열 구조 분해 할당

**기본 사용법**

```javascript
let c1, c2, c3;
[c1, c2, c3] = ["green", "blue", "purple"];
console.log(c1); // green
console.log(c2); // blue
console.log(c3); // purple
```

**요소 개수 불일치**

```javascript
// 할당할 변수가 더 적은 경우
let c1, c2;
[c1, c2] = ["green", "blue", "purple"];
console.log(c1); // green
console.log(c2); // blue

// 할당할 변수가 더 많은 경우
let c1, c2, c3, c4;
[c1, c2, c3, c4] = ["green", "blue", "purple"];
console.log(c1); // green
console.log(c2); // blue
console.log(c3); // purple
console.log(c4); // undefined
```

**기본값 설정**

```javascript
let c1, c2, c3, c4;
[c1, c2, c3, c4 = "yellow"] = ["green", "blue", "purple"];
console.log(c1); // green
console.log(c2); // blue
console.log(c3); // purple
console.log(c4); // yellow
```

**값 교환**

```javascript
// 구조 분해 할당 전 (temp 사용)
let a = 10;
let b = 5;
let temp;

temp = a;
a = b;
b = temp;

console.log(a, b); // 5 10

// 구조 분해 할당 후
let a = 10;
let b = 5;
[a, b] = [b, a];

console.log(a, b); // 5 10
```

#### 객체 구조 분해 할당

**기본 사용법**

```javascript
// 구조 분해 할당 전
let colors = {
  c1: "green",
  c2: "blue",
  c3: "purple",
};

let c1 = colors.c1;
let c2 = colors.c2;
let c3 = colors.c3;

console.log(c1); // green
console.log(c2); // blue
console.log(c3); // purple

// 구조 분해 할당 후
let colors = {
  c1: "green",
  c2: "blue",
  c3: "purple",
};

let { c1, c2, c3 } = colors; // 분해할 객체

console.log(c1); // green
console.log(c2); // blue
console.log(c3); // purple
```

**변수명 변경**

```javascript
// 구조 분해 할당 전
let colors = {
  c1: "green",
  c2: "blue",
  c3: "purple",
};

let color1 = colors.c1;
let color2 = colors.c2;
let color3 = colors.c3;

console.log(color1); // green
console.log(color2); // blue
console.log(color3); // purple

// 구조 분해 할당 후 (변수명 변경)
let colors = {
  c1: "green",
  c2: "blue",
  c3: "purple",
};

let { c1: color1, c2: color2, c3: color3 } = colors;
// colors 객체의 c1, c2, c3 각각 color1, color2, color3로 변경

console.log(color1); // green
console.log(color2); // blue
console.log(color3); // purple
```

---

### 📤 Spread와 Rest

#### Spread 문법

배열이나 객체에서 반복적인 부분을 `...` 기호를 사용해 퍼트릴 수 있고, 순서에 상관없이 여러 번 사용할 수도 있습니다.

**객체에서 Spread 사용**

```javascript
// spread 사용 전
const toy = {
  type: "bear",
  price: 15000,
};

const blueToy = {
  type: "bear",
  price: 15000,
  color: "blue",
};

const yellowToy = {
  type: "bear",
  price: 15000,
  color: "yellow",
};

// spread 사용 후
const toy = {
  type: "bear",
  price: 15000,
};

const blueToy = {
  ...toy, // toy 객체의 모든 속성을 복사
  color: "blue",
};

const yellowToy = {
  ...toy, // toy 객체의 모든 속성을 복사
  color: "yellow",
};

console.log(blueToy); // { type: "bear", price: 15000, color: "blue" }
console.log(yellowToy); // { type: "bear", price: 15000, color: "yellow" }
```

**배열에서 Spread 사용**

```javascript
const color1 = ["red", "orange", "yellow"];
const color2 = ["blue", "navy", "purple"];

const rainbow = [...color1, "green", ...color2];
console.log(rainbow); // ["red", "orange", "yellow", "green", "blue", "navy", "purple"]
```

#### Rest 문법

**객체에서 Rest 사용**

```javascript
// rest 사용 전
const blueToy = {
  type: "bear",
  price: 15000,
  color: "blue",
};

const { type, price, color } = blueToy;

console.log(type); // bear
console.log(price); // 15000
console.log(color); // blue

// rest 사용 후
const blueToy = {
  type: "bear",
  price: 15000,
  color: "blue",
};

const { type, ...rest } = blueToy; // type을 제외한 나머지를 rest에 할당

console.log(type); // bear
console.log(rest); // { price: 15000, color: "blue" }

// ❌ 주의: rest는 항상 맨 마지막에 작성해야 함
// const { ...rest, type } = blueToy; // SyntaxError
```

**배열에서 Rest 사용**

```javascript
const color = ["red", "orange", "yellow", "green"];
const [c1, c2, ...rest] = color;

console.log(c1, c2); // red orange
console.log(rest); // ["yellow", "green"]
```

**함수 매개변수에서 Rest 사용**

```javascript
// rest 사용 전
const print = (a, b, c, d, e, f) => {
  console.log([c, d, e, f]);
};

print(1, 2, 3, 4, 5, 6);

// rest 사용 후
const print = (a, b, ...rest) => {
  console.log(a); // 1
  console.log(b); // 2
  console.log(rest); // [3, 4, 5, 6]
};

print(1, 2, 3, 4, 5, 6);
```

#### Spread와 Rest 함께 사용

**함수 호출 시 Spread 사용**

```javascript
// 사용 전
const print = (a, b, c, d, e, f) => {
  console.log(a, b, c, d, e, f);
};

const numbers = [1, 2, 3, 4, 5, 6];
print(numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], numbers[5]);

// 사용 후
const print = (a, b, c, d, e, f) => {
  console.log(a, b, c, d, e, f);
};

const numbers = [1, 2, 3, 4, 5, 6];
print(...numbers); // spread
```

**Rest와 Spread 함께 사용**

```javascript
const print = (...rest) => {
  // rest: 매개변수를 배열로 받음
  console.log(rest);
};

const numbers = [1, 2, 3, 4, 5, 6];
print(...numbers); // spread: 배열을 개별 요소로 펼침
// 출력: [1, 2, 3, 4, 5, 6]
```

> 📌 **정리**
>
> - **Spread 문법**: 객체나 배열에서 중복된 부분을 퍼트릴 때, 혹은 함수를 호출할 때 인수로 전달할 값들을 퍼트릴 때 사용
> - **Rest 문법**: 객체나 배열에서 특정 부분을 하나의 객체나 배열로 묶어야 할 때, 구조 분해 할당을 사용해 배열이나 객체의 값을 묶어서 할당할 때, 그리고 함수의 매개변수로 많은 값들을 전달받거나 특정 매개변수들을 제외한 나머지 매개변수들을 묶어서 사용할 때 사용
>
> Rest 매개변수는 함수의 매개변수가 매우 많거나, 몇 개가 될지 모를 때, 함수에서 받아온 매개변수들을 배열로 나타내야 될 때 유용하게 사용할 수 있는 문법입니다.

---

### 🎯 this와 화살표 함수

#### JavaScript의 this

JavaScript에서 `this`는 **누가 함수를 호출했는지**(호출 주체)에 따라 달라집니다.

**기본 개념**

```javascript
// 일반 함수에서의 this
const user = {
  name: "채현",
  say: function () {
    console.log(`안녕, ${this.name}`); // this는 user 객체를 가리킴
  },
};

user.say(); // "안녕, 채현"
```

#### 일반 함수 vs 화살표 함수의 this

**일반 함수의 this**

```javascript
const user = {
  name: "채현",
  say: function () {
    console.log(this.name); // this는 user 객체
  },
};

user.say(); // "채현"

// 다른 변수에 할당하면 this가 바뀜
const sayHi = user.say;
sayHi(); // undefined (전역 객체에서 호출)
```

**화살표 함수의 this**

```javascript
const user = {
  name: "채현",
  say: () => {
    console.log(this.name); // 화살표 함수는 자신의 this가 없음
  },
};

user.say(); // undefined (상위 스코프의 this 사용)
```

> 📌 **핵심**: 화살표 함수는 자기만의 `this`가 없습니다. 대신 상위 환경(lexical scope)의 `this`를 그대로 사용합니다.

#### setTimeout에서의 this

**일반 함수 사용 시 문제점**

```javascript
const user = {
  name: "채현",
  say: function () {
    console.log(`즉시: ${this.name}`); // "즉시: 채현"

    setTimeout(function () {
      console.log(`1초 후: ${this.name}`); // "1초 후: undefined"
      // setTimeout 안의 this는 전역 객체(window)를 가리킴
    }, 1000);
  },
};

user.say();
```

**화살표 함수로 해결**

```javascript
const user = {
  name: "채현",
  say: function () {
    console.log(`즉시: ${this.name}`); // "즉시: 채현"

    setTimeout(() => {
      console.log(`1초 후: ${this.name}`); // "1초 후: 채현"
      // 화살표 함수는 상위 스코프(say 함수)의 this를 유지
    }, 1000);
  },
};

user.say();
```

**bind() 메서드 사용법 (대안)**

```javascript
const user = {
  name: "채현",
  say: function () {
    setTimeout(
      function () {
        console.log(`1초 후: ${this.name}`);
      }.bind(this),
      1000
    ); // bind로 this를 명시적으로 바인딩
  },
};

user.say(); // "1초 후: 채현"
```

<this 예제 추가>
// 예시: 게임 캐릭터 클래스
class 게임캐릭터 {
constructor({ 이름, 레벨, 체력, 초기메시지 }) {
// 계속 사용하는 것들 → this에 저장
this.이름 = 이름; // 공격할 때, 레벨업할 때 계속 사용
this.레벨 = 레벨; // 경험치 계산할 때 계속 사용  
 this.체력 = 체력; // 전투 중 계속 변경됨

    // 한 번만 사용하는 것들 → this에 저장 안 함
    // this.초기메시지 = 초기메시지;  // 불필요!
    console.log(초기메시지);  // 여기서 한 번만 출력하고 끝

}

공격() {
console.log(`${this.이름}이 공격했다!`); // 이름 계속 사용
}

레벨업() {
this.레벨++; // 레벨 계속 사용
}
}

**정리**

| 함수 타입       | this 결정        | 상황별 this             |
| --------------- | ---------------- | ----------------------- |
| **일반 함수**   | 호출 시점에 결정 | 호출 주체에 따라 변함   |
| **화살표 함수** | 선언 시점에 결정 | 상위 스코프의 this 유지 |

---

### 💡 핵심 개념 정리

#### 바닐라 JS의 의미

> 🍦 **바닐라 JavaScript**는 "바닐라 아이스크림"이 기본 맛인 것처럼, 아무런 프레임워크나 라이브러리(React, Vue, jQuery 등)를 쓰지 않은 **순수 자바스크립트**를 뜻합니다.

#### 비교 연산 주의사항

```javascript
let age = 20;

// ✅ 올바른 비교: &&로 두 조건을 동시에 확인
if (age > 10 && age < 40) {
  console.log("청년입니다.");
}

// ❌ 10 < age < 40 은 JS에서 왼쪽부터 계산되어 항상 참처럼 동작
// (파이썬에서는 가능하지만, JS에서는 안 됨)
```

#### 변수 초기화

```javascript
let result; // 값이 없으면 자동으로 undefined
```

#### return vs console.log

```javascript
// return: 함수가 값을 돌려줌
// console.log: 콘솔에 직접 출력

function greet(name) {
  return `안녕, ${name}`;
}

console.log(greet("가나")); // 👉 안녕, 가나
```

#### 조건문에서 `!` 연산자 활용

```javascript
const userName = "";

// `!`는 "~이 아니다"라는 뜻
// `if (!userName)` 은 userName이 빈 문자열 "", null, undefined, 0, false일 때 true가 된다
// 즉, 값이 비어있거나 없으면 실행되는 조건문

if (!userName) {
  console.log("데이터가 없습니다.");
} else {
  console.log("데이터가 있습니다.");
}
```

#### 이벤트 핸들러 주의사항

**함수 참조 vs 함수 호출**

```javascript
const button = document.getElementById("myButton");

// ✅ 올바른 방법: 함수 참조만 넘기기
button.addEventListener("click", handleClick);

// ❌ 잘못된 방법: 함수를 즉시 실행
button.addEventListener("click", handleClick()); // 즉시 실행되어 undefined가 전달됨

function handleClick() {
  console.log("버튼 클릭됨!");
}
```

**익명 함수 사용**

```javascript
button.addEventListener("click", function () {
  console.log("익명 함수로 처리");
});

// 화살표 함수 사용
button.addEventListener("click", () => {
  console.log("화살표 함수로 처리");
});
```

#### data-\* 속성

HTML 태그에 개발자가 원하는 사용자 정의 데이터를 저장할 수 있습니다.

**HTML에서 data-\* 속성 사용**

```html
<button data-user-id="42" data-action="delete">삭제</button>
<div data-product-name="laptop" data-price="1500000">노트북</div>
```

**JavaScript에서 data-\* 속성 접근**

```javascript
const button = document.querySelector("button");

// dataset 객체로 접근 (camelCase로 변환됨)
console.log(button.dataset.userId); // "42"
console.log(button.dataset.action); // "delete"

// getAttribute()로 접근
console.log(button.getAttribute("data-user-id")); // "42"

// data-* 속성 설정
button.dataset.newData = "새로운 값";
button.setAttribute("data-custom", "사용자 정의");
```

**실제 활용 예시**

```javascript
// 여러 버튼에 각각 다른 데이터 연결
document.querySelectorAll(".delete-btn").forEach((btn) => {
  btn.addEventListener("click", (e) => {
    const userId = e.target.dataset.userId;
    const userName = e.target.dataset.userName;

    if (confirm(`${userName}님을 정말 삭제하시겠습니까?`)) {
      deleteUser(userId);
    }
  });
});
```

> 📌 **data-\* 속성 규칙**
>
> - 속성명은 `data-`로 시작해야 함
> - 소문자와 하이픈(-)만 사용 가능
> - JavaScript에서는 camelCase로 변환됨 (`data-user-name` → `dataset.userName`)

### 클로저(Closure) 심화 이해

#### 클로저가 왜 특별한가?

일반적으로 함수가 끝나면 지역변수는 메모리에서 사라져야 합니다. 하지만 JavaScript는 나중에 사용될 변수를 자동으로 감지해서 보관해둡니다.

```javascript
// 일반적인 경우: 함수 끝나면 변수 사라짐
function normalFunction() {
  const localVar = "지역변수";
  console.log(localVar); // 사용 가능
} // 함수 끝 → localVar 메모리에서 해제

// 클로저: 함수 끝나도 변수 보존
function createClosure() {
  const shouldDisappear = "사라져야 할 변수";

  return function () {
    console.log(shouldDisappear); // 🤯 어떻게 여전히 접근 가능?
  };
} // 함수 끝났는데도 shouldDisappear가 보존됨!

const savedFunction = createClosure(); // createClosure 실행 완료
savedFunction(); // "사라져야 할 변수" 출력 (클로저의 마법!)
```

#### MiniAlert에서 클로저 동작

```javascript
class MiniAlert {
  constructor(message) {
    this.message = message;
    const tempMessage = "임시 메시지"; // 원래라면 constructor 끝나면 사라져야 함

    setTimeout(() => {
      console.log("A:", this.message); // 객체 속성이라 당연히 접근 가능
      console.log("B:", tempMessage); // 클로저 덕분에 접근 가능!
    }, 1000);
  } // constructor 끝 → JavaScript가 tempMessage를 특별히 보관
}
```

#### 클로저의 실용적 활용

```javascript
// 비공개 변수 만들기 (캡슐화)
function createCounter(name) {
  let count = 0; // 외부에서 직접 접근 불가능한 비공개 변수

  return {
    increment: function () {
      count++; // 클로저로 count에 접근
      console.log(`${name}: ${count}`);
    },

    getCount: function () {
      return count; // 클로저로 count에 접근
    },
  };
}

const counter1 = createCounter("첫번째");
const counter2 = createCounter("두번째");

counter1.increment(); // 첫번째: 1
counter2.increment(); // 두번째: 1
counter1.increment(); // 첫번째: 2

// count 변수에 직접 접근 불가능 (보안성)
// console.log(count); // ❌ ReferenceError
```

> 📌 **클로저 핵심 정리**
>
> - **일반 함수**: 실행 완료 후 지역변수 메모리 해제
> - **클로저**: JavaScript가 나중에 사용될 변수를 자동으로 보존
> - **활용**: 비공개 변수, 모듈 패턴, 콜백 함수에서 데이터 유지

---

## 📚 추가 학습 자료

### 비동기 처리 기초

자바스크립트는 싱글 스레드(Single Threaded) 언어로 한 번에 하나의 작업만 수행할 수 있습니다. 그렇기 때문에 이렇게 여러 스레드를 사용해 작업을 처리하는 이 멀티 스레드(Multi Threaded) 방식으로는 작업을 처리할 수 없습니다.
